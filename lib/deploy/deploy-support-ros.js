'use strict';

const { sleep } = require('../time');
const uuid = require('uuid');
const client = require('../client');
const { getProfile } = require('../profile');
const _ = require('lodash');
const { green, red } = require('colors');
const debug = require('debug');
const promiseRetry = require('../retry');
const { promptForConfirmContinue } = require('../init/prompt');

const Table = require('cli-table3');

const log = require('single-line-log').stdout;

const DEFAULT_ROS_TIMEOUT_IN_MINS = 10;
const requestOption = {
  method: 'POST'
};

const ROS_STATUS_COMPLETE = ['CREATE_COMPLETE', 'UPDATE_COMPLETE'];
const ROS_STATUS_FAILED = ['CREATE_FAILED', 'UPDATE_FAILED'];

const ROS_ROLLBACK_PREFIX = 'ROLLBACK';

const ROS_RESOURCE_TYPE = 'ALIYUN::ROS::Stack';

const tableHead = ['Id', 'ResourceType', 'Action', 'Property'];

const eventTableHead = ['id', 'status'];

async function findRosStack(rosClient, region, stackName) {
  const pageSize = 50;
  let requestPageNumber = 0;
  let totalCount;
  let pageNumber;

  let stack;

  do {
    const params = {
      'RegionId': region,
      'StackName.1': stackName,
      'PageSize': pageSize,
      'PageNumber': ++requestPageNumber,
      'ShowNestedStack': false
    };

    const rs = await rosClient.request('ListStacks', params, requestOption);

    totalCount = rs.TotalCount;
    pageNumber = rs.PageNumber;

    const stacks = rs.Stacks;

    stack = _.find(stacks, { StackName: stackName });
  } while (!stack && totalCount && pageNumber && pageNumber * pageSize < totalCount);

  return (stack || {}).StackId;
}

function generateChangeSetName() {
  return 'fun-' + uuid.v4();
}

async function updateChangeSet(rosClient, region, stackName, stackId, tpl) {
  try {
    const params = {
      'RegionId': region,
      'ChangeSetName': generateChangeSetName(),
      'StackId': stackId,
      'ChangeSetType': 'UPDATE',
      'Description': 'generated by Funcraft',
      'TemplateBody': JSON.stringify(tpl),
      'DisableRollback': false,
      'TimeoutInMinutes': DEFAULT_ROS_TIMEOUT_IN_MINS
    };
    debug('update stacks, params %s', params);

    const res = await rosClient.request('CreateChangeSet', params, requestOption);
    return res.ChangeSetId;
  } catch (e) {
    if (e.name === 'NotSupportedError' && e.data && e.data.Message && e.data.Message.indexOf('Update the completely same stack') !== -1) {
      throw new Error(red(`no need to update, your stack ${stackName} is already latest`)); // todo: 
    } else {
      throw e;
    }
  }
}

async function createChangeSet(rosClient, region, stackName, tpl) {
  const params = {
    'RegionId': region,
    'ChangeSetName': generateChangeSetName(),
    'StackName': stackName,
    'ChangeSetType': 'CREATE',
    'Description': 'generated by Funcraft',
    'TemplateBody': JSON.stringify(tpl),
    'DisableRollback': false,
    'TimeoutInMinutes': DEFAULT_ROS_TIMEOUT_IN_MINS
  };

  debug('create stacks, params %s', params);

  const res = await rosClient.request('CreateChangeSet', params, requestOption);

  return {
    'changeSetId': res.ChangeSetId,
    'stackId': res.StackId
  };
}

async function execChangeSet(rosClient, region, changeSetId) {
  const params = {
    'RegionId': region,
    'ChangeSetId': changeSetId
  };

  await rosClient.request('ExecuteChangeSet', params, requestOption);
}

async function waitCompleted(rosClient, stackId, region) {

  let status;
  let res;
  const params = {
    'StackId': stackId,
    'RegionId': region
  };

  console.log();

  do {

    await sleep(1000);
  
    res = await rosClient.request('GetStack', params, requestOption);

    // https://help.aliyun.com/document_detail/132088.html?spm=a2c4g.11186623.6.812.24c031b26lZ7iD
    if (res.Status.indexOf(ROS_ROLLBACK_PREFIX) !== -1) {

      throw new Error(`\nROS deployment failed: Fun detected that the region of your OSS bucket is not in the same region as the current '${region}'.`);
    }

    if ([...ROS_STATUS_COMPLETE, ...ROS_STATUS_FAILED].includes(res.Status)) {

      status = res.Status;
    } else {

      console.log(`waiting for status to be complete, now status is ${res.Status}.`);
    }
  } while (!status);

  if (ROS_STATUS_FAILED.includes(status)) { throw new Error(`ROS deployment failed, the reason is: ${res.StatusReason}`); }
}

async function getChangeSet(rosClient, changeSetId, region) {

  const params = {
    'RegionId': region,
    'ChangeSetId': changeSetId,
    'ShowTemplate': true
  };

  const res = await rosClient.request('GetChangeSet', params, requestOption);

  return res.Changes;
}

// ┌────────────────┬──────────────────────┬────────┬─────────────┐
// │ Id             │ ResourceType         │ Action │ Propertity  │
// ├────────────────┼──────────────────────┼────────┼─────────────┤
// │ RosDemo        │ ALIYUN::FC::Service  │ Modify │ Description │
// ├────────────────┼──────────────────────┼────────┼─────────────┤
// │                │                      │        │ Code        │
// │                │                      │        ├─────────────┤
// │ RosDemoRosDemo │ ALIYUN::FC::Function │ Modify │ Timeout     │
// │                │                      │        ├─────────────┤
// │                │                      │        │ Runtime     │
// └────────────────┴──────────────────────┴────────┴─────────────┘

async function localDiffDisplay(changes) {
  if (_.isEmpty(changes)) { return; }

  const table = new Table({
    head: tableHead,
    style: {
      head: ['green'],
      border: [] //disable colors for the border
    }});

  const map = new Map();

  _.forEach(changes, change => {
    // key: [LogicalResourceId, ResourceType, Action] 
    // value: [Name1, Name2.....]
    const logicalResourceId = change.ResourceChange.LogicalResourceId;
    const resourceType = change.ResourceChange.ResourceType;
    const action = change.ResourceChange.Action;

    const key = [logicalResourceId, resourceType, action];
    const value = change.ResourceChange.Details.map(detail => detail.Target.Name);
    map.set(key, value);
  });

  for (let [key, value] of map.entries()) {

    const valueSize = value.length;

    const line = [
      {rowSpan: valueSize, content: key[0], vAlign: 'center'},
      {rowSpan: valueSize, content: key[1], vAlign: 'center'},
      {rowSpan: valueSize, content: key[2], vAlign: 'center'}
    ];

    if (_.isEmpty(value)) {

      line.push('/');
      table.push(line);
    } else {
      let first = true;

      for (const pro of value) {
        if (first) {
          line.push(pro);
          table.push(line);
          first = false;
        } else {
          table.push([pro]);
        }
      }
    }
  }
  console.log(`\nchangeset difference table:\n`);
  console.log(table.toString());
  console.log();
}

async function listStackEvents(rosClient, stackId, region, stackName) {

  console.log('resource stack and the following events:\n');

  let isComplete = false;

  const pageSize = 50;
  let requestPageNumber = 1;
  let totalCount;
  let pageNumber;

  let leftPageCollect = [];

  do {

    const table = new Table({
      head: eventTableHead,
      style: {
        head: ['green'],
        border: []
      },
      colWidths: [25, 20] //set the widths of each column (optional)
    });

    const params = {
      'StackId': stackId,
      'RegionId': region,
      'PageSize': pageSize,
      'PageNumber': requestPageNumber
    };

    await sleep(2000);

    const rs = await rosClient.request('ListStackEvents', params, requestOption);

    const events = rs.Events;

    totalCount = rs.TotalCount;
    pageNumber = rs.PageNumber;

    const index = _.findIndex(events, event => {

      return event.ResourceType === ROS_RESOURCE_TYPE && !_.includes(ROS_STATUS_COMPLETE, event.Status);
    });
  
    // 0: find it but not begin  
    if (index === 0 && requestPageNumber === 1) {
      continue;
    }

    // -1: not find
    if (index === -1) {

      leftPageCollect = _.concat(leftPageCollect, events);
      requestPageNumber++;
      continue;
    }

    const concatEvents = _.concat(leftPageCollect, events);

    let sliceEvents;

    if (requestPageNumber > 1) {

      sliceEvents = _.slice(concatEvents, 0, (requestPageNumber - 1) * pageSize + events.length - 1);
      
    } else {

      sliceEvents = _.slice(concatEvents, 0, index);
    }

    const complete = sliceEvents.filter(s => {
      return _.includes(ROS_STATUS_COMPLETE, s.Status);
    });

    const firstEvent = _.first(sliceEvents);

    isComplete = firstEvent.ResourceType === ROS_RESOURCE_TYPE && _.includes(ROS_STATUS_COMPLETE, firstEvent.Status);

    if (isComplete) {

      _.remove(complete, e => {

        return e.LogicalResourceId === stackName;
      });

      complete.forEach(e => {

        table.push([e.LogicalResourceId, e.Status]);
      });
    } else {

      const logicalResourceIds = complete.map(c => c.LogicalResourceId);

      _.remove(sliceEvents, e => {

        return _.includes(logicalResourceIds, e.LogicalResourceId) && !_.includes(ROS_STATUS_COMPLETE, e.Status);
      });

      // Duplicate removal
      _.unionBy(sliceEvents, union => union.LogicalResourceId && union.Status)
        .forEach(e => {
          table.push([e.LogicalResourceId, e.Status]);
        });
    }

    log(table.toString());

    //reset
    requestPageNumber = 1;
    leftPageCollect = [];

  } while (!isComplete && totalCount && pageNumber && pageNumber * pageSize < totalCount);
}

async function deployByRos(stackName, tpl, assumeYes) {
  const profile = await getProfile();
  const region = profile.defaultRegion;

  const rosClient = await client.getRosClient();

  let stackId = await findRosStack(rosClient, region, stackName);

  let changeSetId;

  if (!stackId) { // create

    const changeSet = await createChangeSet(rosClient, region, stackName, tpl);
    
    changeSetId = changeSet.changeSetId;
    stackId = changeSet.stackId;

  } else { // update
    changeSetId = await updateChangeSet(rosClient, region, stackName, stackId, tpl);
  }

  const changes = await getChangeSet(rosClient, changeSetId, region);

  await localDiffDisplay(changes);

  if (!assumeYes) {

    if (!await promptForConfirmContinue('Please confirm to continue.')) { return; }
  }

  await promiseRetry(async (retry, times) => {
    try {
      await execChangeSet(rosClient, region, changeSetId);
    } catch (e) {
      if (e.code === 'NotSupported' && e.data && e.data.Message
        && e.data.Message.indexOf('StatusEnum.CREATE_IN_PROGRESS is not supported')) {
        await sleep(1000);
        console.log('changeSet is in \'StatusEnum.CREATE_IN_PROGRESS\' status, try to exectue again');
        retry(e);
      } else {
        throw e;
      }
    }
  });

  await listStackEvents(rosClient, stackId, region, stackName);

  await waitCompleted(rosClient, stackId, region);

  showRosDeployNextTips(region);
}

function showRosDeployNextTips(region) {

  const url = `https://ros.console.aliyun.com/#/stack/${region}`;

  console.log(green(`\nDeploy success, you can login to ${url} to see deploy logs.\n`));
}

module.exports = {
  deployByRos
};